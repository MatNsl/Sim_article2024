---
title: "Draft"
output: html_document
date: "2024-06-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Tessellation

```{r}
# Load necessary library
library(ggplot2)

# Define the size of the square space
space_size <- 10

# Define the size of the smaller squares
square_size <- 1

# Create a data frame to store the coordinates of the squares
squares <- data.frame(
  x = rep(seq(0, space_size - square_size, by = square_size), each = space_size / square_size),
  y = rep(seq(0, space_size - square_size, by = square_size), times = space_size / square_size)
)

# Plot the tessellation
ggplot() +
  geom_tile(data = squares, aes(x = x, y = y), width = square_size, height = square_size, fill = "lightblue", color = "black") +
  coord_fixed() +
  theme_minimal() +
  labs(title = "Square Tessellation", x = "X", y = "Y")
```

## Draft

```{r}
# Tests (preliminaries)

# trees$cell2 <- 1*as.numeric((trees$x %in% seq(200, 300, by = .01)) & (trees$y %in% seq(200, 300, by = .01))) # Problem with 107th tree e.g.
# trees$cell <- 1*as.numeric((200 <= trees$x) & (trees$x < 300) & (200 <= trees$y) & (trees$y < 300))

# trees[trees$cell == 1 & trees$cell2 == 0,]
# Where is the pb?
# 297.21 %in% seq(233, 300, by = .01) # FALSE, idem for numbers below 233
# 297.21 %in% seq(234, 300, by = .01) # TRUE, idem for numbers above 234
```

```{r}
# Un peu long

# PROBLEME: ne garde que le 8 (i.e. le dernier nb)

trees$cell <- rep(0, 30942) # Initialisation de la variable

for (nb in 1:10){ # All the categories (to identify the cells)
for (ligne in 0:599){ # All the lines (en parcourant par rapport aux ordonnées)
  for(c in 1:60){ # En parcourant sur une même ligne
    # if (trees$cell == 0)
    trees$cell <- ifelse(
    # (trees$cell == 0) & 
      (vec[(nb-1)*60 + 1] <= trees$x) & (trees$x < vec[(nb-1)*60 + 1]+1) & (200+ligne <= trees$y) & (trees$y < 200+ligne+1), 
    list[nb], trees$cell)
  }

}
}

# (ligne-1)*trend + 
# (ligne-1)*trend + 
```


```{r}
# Un peu long

# PROBLEME: ne garde que le 8 (i.e. le dernier nb)

trees$cell <- rep(0, 30942) # Initialisation de la variable


for (ligne in 0:599){ # All the lines (en parcourant par rapport aux ordonnées)
  # for(c in 1:60){ # En parcourant sur une même ligne
    for (nb in 1:10){ # All the categories (to identify the cells)
    # if (trees$cell == 0)
    trees$cell <- ifelse(
    # (trees$cell == 0) & 
      (vec[(nb-1)*60 + 1] <= trees$x) & (trees$x < vec[(nb-1)*60 + 1]+1) & (200+ligne <= trees$y) & (trees$y < 200+ligne+1), 
    list[nb], trees$cell)
  }

# }
}
```

```{r}
unique(trees$cell)
```

```{r}
trees$cell3 <- rep(0, 30942)
trees$cell3 <- ifelse(
  (vec[1] <= trees$x) & (trees$x < vec[1]+1) & (vec[1] <= trees$y) & (trees$y < vec[1]+1), 
  1, trees$cell3)
```

```{r}
# Inaccurate cell
trees$cell3 <- ifelse(
  (200 <= trees$x) & (trees$x < 300) & (200 <= trees$y) & (trees$y < 300), 
  1, trees$cell3)
```

```{r}
# Invalid
trees$cell3 <- rep(0, 30942)
for (ligne in 1:60){
  
  for(l in 1:60){
    trees$cell3 <- ifelse(
    (vec[l] <= trees$x) & (trees$x < vec[l]+1) & (vec[1] <= trees$y) & (trees$y < vec[1]+1), 
    list[1], trees$cell3)
  }

}
```

```{r}
# When only focusing on 1 10th of the population
plot(x = trees[trees$cell3 == 9,]$x, y = trees[trees$cell3 == 9,]$y, main = "Forest", panel.first=grid())
# Pretty nice (at one point)
```

```{r}
# Test

trees$cell3 <- rep(0, 30942)
nb = 1
ligne = 0

for(c in 1:60){ # En parcourant sur une même ligne
    # if (trees$cell == 0)
    trees$cell <- ifelse(
    (vec[(c-1)*trend + (nb-1) + 1] <= trees$x) & (trees$x < vec[(c-1)*trend + nb]+1) & (200+ligne <= trees$y) & (trees$y < 200+ligne+1) & trees$cell, 
    list[nb], trees$cell)
  }
```

```{r}
# When only focusing on 1 10th of the population
plot(x = trees[trees$cell == 1,]$x, y = trees[trees$cell == 1,]$y, main = "Forest", panel.first=grid())
```

```{r}
# When only focusing on 
plot(x = trees[trees$cell == 9,]$x, y = trees[trees$cell == 9,]$y, main = "Forest", panel.first=grid())
```

```{r}
# When only focusing on 
plot(x = trees[trees$cell == 0,]$x, y = trees[trees$cell == 0,]$y, main = "Forest", panel.first=grid())
```

# Draft for part after 25 June

```{r}
fun_diag <- function(x,y){
  (x + y) <= 1000
}
```

```{r}
random_points$elt <- random_points$rho2/pi
```

```{r}
est_ratio2 <- sum(random_points$elt)
```

```{r}
integral2(fun_diag, 0, 1000, 0, 1000)
```

```{r}
integrate(function(y) {
  sapply(y, function(y){
    integrate(function(x){
      fun_ratio(x,y)}, 0, 1000)
    })
  }, 0, 1000)

```

# Draft for variance in No_cell.Rmd

```{r}
# var_est <- function(f){
#   random_points$carre <- (random_points$rho1)^2
#   est_carre <- sum((random_points$carre)/pi)
# }
```

# Draft for Trees_circle

```{r}
trees_in <- data.frame(useless = rep(0,30942))
col_names <- c()
for (point in 1:n) {
  new_col <- paste("point", point, sep = "")
  a <- random_points[point,]$x
  b <- random_points[point,]$y
  val <- is_point_in_circle(a, b, trees$x, trees$y, 100)*point
  # val <- is_point_in_circle(round(a, digits = 0), round(b, digits = 0), trees$x, trees$y, 100) #*point
  # if (val != 0){
  #  trees$Is_in_circle <- append(trees$Is_in_circle, val[val != 0])
  # }
  trees_in <- trees_in %>% add_column(new_col = val)
  col_names <- append(col_names, new_col)
}
# unique(trees$Is_in_circle)
trees_in[1] <- NULL
colnames(trees_in) <- col_names
```

```{r}
## Draft

nb_trees <- c()

for (placette in 1:n) {
  nb_trees <- append(nb_trees, sum(trees_in[trees_in$point74 != 0,]))
}

sum((nb_trees)/p)
# 28737017 # TOO MUCH, p is (probably) wrong
# 9.028e+09 # if p unchanged i.e. sum(rep((1/1000)*(1/1000), n))
# 57474033 # TOO MUCH, p is (probably) wrong if sum(rep((1/1000)*(1/1000)*((R^2)*pi)/2, n))
```

```{r}
trees$Is_in_circle <- is_point_in_circle(500, 500, trees$x, trees$y, 100)
unique(trees$Is_in_circle)
```

```{r}
# The sample thus obtained
trees[trees$Is_in_circle == TRUE,]
```

```{r}
total_trees <- nrow(trees[trees$Is_in_circle == TRUE,])
```

```{r}
trees$Is_in_circle <- is_point_in_circle(580.869189, 797.312061, trees$x, trees$y, 100)
unique(trees$Is_in_circle)
```


```{r}
# Marginal density: density of the uniform distribution over 1:1000
# Which leads us to the inclusion density function
p <- sum(rep((1/1000)*(1/1000), n)) # :(
# p

# I would say that p changes: area of each circle over total area for each marginal
# p <- sum(rep((1/1000)*(1/1000)*(R^2)*pi, n)) # :(

# p <- sum(rep((1/1000)*(1/1000)*((R^2)*pi)/2, n))
```

## Circle

# Circle2

```{r}
  # list_trees <- c()
  # for (plant in 1:nrow(trees)) {
  #   if (is_point_in_circle(x1, x2, trees[plant, 1], trees[plant, 2], R)){
  #     list_trees <- append(list_trees, plant)
  #   }
    
  # }
```


## Draft for bootstrap

```{r}
# res[(res$ech1$x == res$ech1$x[1]),]
# res[(res$ech2$x == res$ech1$x[1]),]
# Gives the same pair

# res[(res$ech2$x == res$ech2$x[14]),]
# Gives 1 repeated pair twice for the same sample b = 2
```

```{r}
# Try to do bootstrap, success
# test <- data.frame(col = c(1:3))
# res <- f_boot(test, 3)
```

### Complexity

```{r}
# To evaluate complexity
install.packages("cyclocomp")
```

```{r}
library(cyclocomp)
```

```{r}
cyclocomp(circle_nb) # 1
```

```{r}
# Probably less efficient than the version actually used in Bootstrap.Rmd
start.time <- Sys.time()

rho_boot <- tibble(.rows = n)
for (c in 1:B) {
  # assign(ech_, df_boot[c])
  a <- c()
  for (i in 1:n) {
    a <- append(a, circle_nb(df_boot[i, (2*c)-1], df_boot[i, 2*c], R))
  }
  rho_boot <- rho_boot %>% add_column(new_col = a)
  colnames(rho_boot)[c] <- paste("est", c, sep = "")
}

# List of estimated totals thus obtained from each sample
est_boot <- c()
for (c in 1:B) {
  est_boot <- append(est_boot, sum((rho_boot[c])/p))
}

est_boot <- sort(est_boot)

end.time <- Sys.time()
time.taken1 <- end.time - start.time

time.taken1

# Time difference of 52.57304 secs
# Time difference of 52.57391 secs
# Time difference of 54.01066 secs
```

```{r}
### More efficient??? Slower than the above version

start.time <- Sys.time()

rho_boot <- tibble(.rows = n)
for (c in 1:B) {
  # assign(ech_, df_boot[c])
  a <- c()
  for (i in 1:n) {
    if(circle_nb(df_boot[i, (2*c)-1], df_boot[i, 2*c], R) != 0){
    a <- append(a, circle_nb(df_boot[i, (2*c)-1], df_boot[i, 2*c], R))
    }
  }
  a2 <- append(a, rep(0, n-length(a)))
  rho_boot <- rho_boot %>% add_column(new_col = a2)
  colnames(rho_boot)[c] <- paste("est", c, sep = "")
}

# List of estimated totals thus obtained from each sample
est_boot2 <- c()
for (c in 1:B) {
  est_boot2 <- append(est_boot2, sum((rho_boot[c])/p))
}

est_boot2 <- sort(est_boot2)

end.time <- Sys.time()
time.taken2 <- end.time - start.time

time.taken2

# Idea: "a" is sparse: let's simplify by shortening it
# Time difference of 1.526216 mins :(
# Modif: still not good
# Time difference of 1.45528 mins

# That one works (and still too long)
# Time difference of 1.126081 mins
# Time difference of 1.094733 mins
```

```{r}
# For the version actually used in Bootstrap.Rmd
start.time <- Sys.time()

end.time <- Sys.time()
time.taken3 <- end.time - start.time

time.taken3

# Time difference of 54.02127 secs
# Time difference of 50.4839 secs
# Time difference of 53.94593 secs
```

```{r}
est_boot3 <- c()
for (c in 1:B) {
  a <- c()
  for (i in 1:n) {
    a <- append(a, circle_nb(df_boot[i, (2*c)-1], df_boot[i, 2*c], 15))
  }
  est_boot3 <- append(est_boot3, sum(a/p))
}

est_boot3 <- sort(est_boot3)

```

### A first package

```{r}
# Same result with function?
boot.ci(rho_boot, type = "perc")
# Doesn't work (df_boot, est_boot, rho_boot)
```

```{r}
sum((random_points$x/random_points$y)/p)
```

```{r}
rho <- function(df, indice){
  d <- df[indice,] # to enable boot
  return(sum((d$x/d$y)/p))
}
```

```{r}
res_boot <- boot(data=random_points, statistic=circle_nb)
res_boot
# Doesn't work
```

```{r}
boot.ci(res_boot, type = "norm")
```

```{r}
boot.ci(res_boot, type = "basic")
# Warning in norm.inter(t, (1 + c(conf, -conf))/2) :
#  extreme order statistics used as endpoints
```

```{r}
# boot.ci(res_boot, type = "stud") 
# Error in ci.out[[4L]] : subscript out of bounds
```

```{r}
boot.ci(res_boot, type = "perc") 
# Error in ci.out[[4L]] : subscript out of bounds
```

```{r}
boot.ci(res_boot, type = "bca") 
# Error in bca.ci(boot.out, conf, index[1L], L = L, t = t.o, t0 = t0.o,  : 
#  estimated adjustment 'a' is NA
```

### Another package

```{r}
install.packages("bootstrap")
library(bootstrap)
```

```{r}
## The most simple function
f_try <- function(x){
  1
}
```

```{r}
theta <- function(x){mean(x)}
```

```{r}
patch.boot <- bootstrap(x = random_points$x,nboot = 1000,theta = theta, func=NULL)
```

```{r}
sd(patch.boot$thetastar) # bootstrapped standard error
```

```{r}
bcanon(random_points$x, 1000, theta = theta)
```

```{r}
# xdata <- matrix(rnorm(30),ncol=2)
n <- 100
# theta <- function(x,xdata){ cor(xdata[x,1],xdata[x,2]) }
theta <- function(x,xdata){
  a <- c()
  for (i in 1:n) {
    a <- append(a, circle(xdata[i,1], xdata[i,2], R))
    # Change: circle_nb!!!
  }
  est_nb <- sum((a)/p)
}
results <- bcanon(1:n,150,theta,random_points, alpha = 0.95)
```

```{r}
results$confpoints # NaN
```




