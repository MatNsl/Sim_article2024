---
title: "Bootstrap"
output: pdf_document
date: "2024-06-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
install.packages("pracma") # double integral
install.packages("boot") # for bootstrap
library(readxl) # to read the initial file
library(data.table) # for shift
library(pracma)
library(magrittr) # for pipes
library(tibble) # for add_column
library(boot)
```

Notes from Efron and Tibshirani (1993):
"It is important to note that B = 100 or 200 is not adequate for confidence interval construction, see Chapter 19." (p161)

# Preliminaries

We do not need the artificial forest for now. We just need a virtual 1000x1000 square.

```{r}
# Sample size
n <- 100
```

```{r}
# Marginal density: density of the uniform distribution over 1:1000
# Which leads us to the inclusion density function
p <- sum(rep((1/1000)*(1/1000), n))
p
```

# Creating one sample

```{r}
# Dataframe containing all coordinates of n randomly chosen points
random_points <- data.frame(x = rep(0, n), y = rep(0, n))
```

```{r}
# Uniform sampling over the whole territory
random_points$x <- runif(n, 0, 1000)
random_points$y <- runif(n, 0, 1000)
```

# Creating another sample based on the previous one

```{r}
# Draft
for (point in 1:n) {
  random_points$x
}
```

```{r}
sum((random_points$x/random_points$y)/p)
```

```{r}
rho <- function(df, indice){
  d <- df[indice,] # to enable boot
  return(sum((d$x/d$y)/p))
}
```

```{r}
res_boot <- boot(data=random_points, statistic=rho, R=10)
res_boot
```

```{r}
boot.ci(res_boot, type = "norm")
```

```{r}
boot.ci(res_boot, type = "basic")
# Warning in norm.inter(t, (1 + c(conf, -conf))/2) :
#  extreme order statistics used as endpoints
```

```{r}
# boot.ci(res_boot, type = "stud") 
# Error in ci.out[[4L]] : subscript out of bounds
```

```{r}
boot.ci(res_boot, type = "perc") 
# Error in ci.out[[4L]] : subscript out of bounds
```

```{r}
boot.ci(res_boot, type = "bca") 
# Error in bca.ci(boot.out, conf, index[1L], L = L, t = t.o, t0 = t0.o,  : 
#  estimated adjustment 'a' is NA
```

# Another package

```{r}
install.packages("bootstrap")
library(bootstrap)
```

```{r}
## The most simple function
f_try <- function(x){
  1
}
```

```{r}
theta <- function(x){mean(x)}
```

```{r}
patch.boot <- bootstrap(x = random_points$x,nboot = 1000,theta = theta, func=NULL)
```

```{r}
sd(patch.boot$thetastar) # bootstrapped standard error
```

```{r}
bcanon(random_points$x, 1000, theta = theta)
```

```{r}
circle <- function(x1, x2, R){
  # Produces a local variable based on 2 coordinates (x1, x2) and a radius (R)
  
  # Intermediary step: which trees are inside the circle?
  trees_in <- data.frame(useless = rep(0,30942))
  val <- is_point_in_circle(x1, x2, trees$x, trees$y, R)
  trees_in <- trees_in %>% add_column(new_col = val)
  trees_in[1] <- NULL
  
  # Creation of the local variable
  local_var <- sum(trees_in[new_col != 0,]/area_circle)
  return(local_var) # A single number
}
```

```{r}
f_boot <- function(sample){
  
}
```

```{r}
# xdata <- matrix(rnorm(30),ncol=2)
n <- 100
# theta <- function(x,xdata){ cor(xdata[x,1],xdata[x,2]) }
theta <- function(x,xdata){
  a <- c()
  for (i in 1:n) {
    a <- append(a, circle(xdata[i,1], xdata[i,2], R))
  }
  est_nb <- sum((a)/p)
}
results <- bcanon(1:n,150,theta,random_points, alpha = 0.95)
```

```{r}
results$confpoints # NaN
```

```{r}

```

