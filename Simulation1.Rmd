---
title: "Simulation"
output: pdf_document
date: "2024-06-20"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readxl) # to read the initial file
library(data.table) # for shift
```


```{r}
trees <- read_excel("~/work/Sim_article2024/artificial_forest_round.xls")
```

# First approach

```{r}
# First visualisation
plot(x = trees$x, y = trees$y, main = "Forest")
```


```{r}
# True values
cat("Il y a au total", length(trees$x), "arbres et un volume total de", sum(trees$v), "\n", "Soit un volume moyen de", mean(trees$v), "\n", "Le diamètre moyen à hauteur de poitrine est de", mean(trees$d130))
```

```{r}
plot(x = trees$x, y = trees$y, main = "Forest", panel.first=grid())

```

# Creating cells

We need to create another variable to indicate in which cell is each tree

```{r}
# Randomizing the positions of the numbers used to identify cells
list <- sample(1:10)
```

```{r}
# Shift considered to add randomization
trend <- as.numeric(sample(1:10, 1))
```

```{r}
n <- 600 # dimension of a cell = 1 unit x 1 unit
vec <- c() # vector containing coordinates of cells
for (j in 0:9){ # for each number (1 to 10)
  for (i in 0:((n/10)-1)){ # translation
    vec <- append(vec, 200+j+10*i)
  }
}
```

```{r}
rm(i, j) # Useless outside loops
```

## 1st step (1 for loop)
One line, one number, no shift yet
```{r}
for (k in 1:60) { # nombre de fois où on obtient un même identifiant pour une ligne donnée
    trees$cell <- ifelse(
    (vec[k] <= trees$x) & (trees$x < vec[k]+1) & (200 <= trees$y) & (trees$y < 200+1), 
    list[1], trees$cell)
}
```

## 2nd step (2 for loops)
All the lines, still one number

```{r}
list_stable <- list
```

```{r}
for (l in 1:599) {
  for (k in 1:60) { # nombre de fois où on obtient un même identifiant pour une ligne donnée
    trees$cell <- ifelse(
    (vec[k] <= trees$x) & (trees$x < vec[k]+1) & (200 + (l-1) <= trees$y) & (trees$y < 200+l), 
    # list[1 + trend*(l-1)], 
    list_stable[1],
    trees$cell)
  }
  list <- shift(list, n = trend, type = "cyclic") # shift for each line
}
```

```{r}
# When only focusing on 1 10th of the population
plot(x = trees[trees$cell == 4,]$x, y = trees[trees$cell == 4,]$y, main = "Echantillonnage", panel.first=grid())
```

## 3rd step (3 for loops)
The same thing as before but with all possible identifiers (from 1 to 10).
```{r}
for (nb in 1:10) {
  list <- list_stable
  for (l in 1:599) {
  for (k in 1:60) { # nombre de fois où on obtient un même identifiant pour une ligne donnée
    trees$cell <- ifelse(
    (vec[k + (nb-1)*60] <= trees$x) & (trees$x < vec[k + (nb-1)*60] + 1) & (200 + (l-1) <= trees$y) & (trees$y < 200+l), 
    list_stable[nb],
    trees$cell)
  }
  list <- shift(list, n = trend, type = "cyclic") # shift for each line
}
}
```

```{r}
# When only focusing on 1 10th of the population
plot(x = trees[trees$cell == 4,]$x, y = trees[trees$cell == 4,]$y, main = "Echantillonnage", panel.first=grid())
```

```{r}
# When only focusing on 1 10th of the population
plot(x = trees[trees$cell == 9,]$x, y = trees[trees$cell == 9,]$y, main = "Echantillonnage", panel.first=grid())
```

```{r}
# When only focusing on the null values
plot(x = trees[trees$cell == 0,]$x, y = trees[trees$cell == 0,]$y, main = "Echantillonnage", panel.first=grid())
```

```{r}
trees[trees$cell == 0,] # 4 trees that do not fill in any cell
# Common characteristic: y is very high
```

```{r}
trees[(trees$cell != 0) & (trees$y >= 799),] # vide
# Problème d'arrondi pour les y
```

## Draft

```{r}
# Tests (preliminaries)

# trees$cell2 <- 1*as.numeric((trees$x %in% seq(200, 300, by = .01)) & (trees$y %in% seq(200, 300, by = .01))) # Problem with 107th tree e.g.
# trees$cell <- 1*as.numeric((200 <= trees$x) & (trees$x < 300) & (200 <= trees$y) & (trees$y < 300))

# trees[trees$cell == 1 & trees$cell2 == 0,]
# Where is the pb?
# 297.21 %in% seq(233, 300, by = .01) # FALSE, idem for numbers below 233
# 297.21 %in% seq(234, 300, by = .01) # TRUE, idem for numbers above 234
```

```{r}
# Un peu long

# PROBLEME: ne garde que le 8 (i.e. le dernier nb)

trees$cell <- rep(0, 30942) # Initialisation de la variable

for (nb in 1:10){ # All the categories (to identify the cells)
for (ligne in 0:599){ # All the lines (en parcourant par rapport aux ordonnées)
  for(c in 1:60){ # En parcourant sur une même ligne
    # if (trees$cell == 0)
    trees$cell <- ifelse(
    # (trees$cell == 0) & 
      (vec[(nb-1)*60 + 1] <= trees$x) & (trees$x < vec[(nb-1)*60 + 1]+1) & (200+ligne <= trees$y) & (trees$y < 200+ligne+1), 
    list[nb], trees$cell)
  }

}
}

# (ligne-1)*trend + 
# (ligne-1)*trend + 
```


```{r}
# Un peu long

# PROBLEME: ne garde que le 8 (i.e. le dernier nb)

trees$cell <- rep(0, 30942) # Initialisation de la variable


for (ligne in 0:599){ # All the lines (en parcourant par rapport aux ordonnées)
  # for(c in 1:60){ # En parcourant sur une même ligne
    for (nb in 1:10){ # All the categories (to identify the cells)
    # if (trees$cell == 0)
    trees$cell <- ifelse(
    # (trees$cell == 0) & 
      (vec[(nb-1)*60 + 1] <= trees$x) & (trees$x < vec[(nb-1)*60 + 1]+1) & (200+ligne <= trees$y) & (trees$y < 200+ligne+1), 
    list[nb], trees$cell)
  }

# }
}
```

```{r}
unique(trees$cell)
```

```{r}
trees$cell3 <- rep(0, 30942)
trees$cell3 <- ifelse(
  (vec[1] <= trees$x) & (trees$x < vec[1]+1) & (vec[1] <= trees$y) & (trees$y < vec[1]+1), 
  1, trees$cell3)
```

```{r}
# Inaccurate cell
trees$cell3 <- ifelse(
  (200 <= trees$x) & (trees$x < 300) & (200 <= trees$y) & (trees$y < 300), 
  1, trees$cell3)
```

```{r}
# Invalid
trees$cell3 <- rep(0, 30942)
for (ligne in 1:60){
  
  for(l in 1:60){
    trees$cell3 <- ifelse(
    (vec[l] <= trees$x) & (trees$x < vec[l]+1) & (vec[1] <= trees$y) & (trees$y < vec[1]+1), 
    list[1], trees$cell3)
  }

}
```

```{r}
# When only focusing on 1 10th of the population
plot(x = trees[trees$cell3 == 9,]$x, y = trees[trees$cell3 == 9,]$y, main = "Forest", panel.first=grid())
# Pretty nice (at one point)
```

```{r}
# Test

trees$cell3 <- rep(0, 30942)
nb = 1
ligne = 0

for(c in 1:60){ # En parcourant sur une même ligne
    # if (trees$cell == 0)
    trees$cell <- ifelse(
    (vec[(c-1)*trend + (nb-1) + 1] <= trees$x) & (trees$x < vec[(c-1)*trend + nb]+1) & (200+ligne <= trees$y) & (trees$y < 200+ligne+1) & trees$cell, 
    list[nb], trees$cell)
  }
```

```{r}
# When only focusing on 1 10th of the population
plot(x = trees[trees$cell == 1,]$x, y = trees[trees$cell == 1,]$y, main = "Forest", panel.first=grid())
```

```{r}
# When only focusing on 
plot(x = trees[trees$cell == 9,]$x, y = trees[trees$cell == 9,]$y, main = "Forest", panel.first=grid())
```

```{r}
# When only focusing on 
plot(x = trees[trees$cell == 0,]$x, y = trees[trees$cell == 0,]$y, main = "Forest", panel.first=grid())
```


# Sampling one point and "creating a circle around"

```{r}
a <- runif(1, 200, 800)
b <- runif(1, 200, 800)
```

```{r}
# Function to check if a point is inside the circle
is_point_in_circle <- function(x, y, h, k, R) {
  # Calculate the squared distance between the point and the circle's center
  squared_distance <- (x - h)^2 + (y - k)^2
  # Check if the squared distance is less than or equal to the squared radius
  return(squared_distance <= R^2)
}

trees$Is_in_circle <- is_point_in_circle(a, b, trees$x, trees$y, 5)
```

```{r}
# The sample thus obtained
trees[trees$Is_in_circle == TRUE,]
```

```{r}
# When considering only one circle
total_trees <- nrow(trees[trees$Is_in_circle == TRUE,])
total_d130 <- sum(trees[trees$Is_in_circle == TRUE,]$d130)
```

## One point at random in each cell with a given identifier

Second stage of first phase

```{r}
random_points <- data.frame(x = numeric(), y = numeric())
```

```{r}

a <- runif(1, vec[1], vec[1] + 1)
b <- runif(1, vec[1], vec[1] + 1)
```

```{r}
nb <- sample(1:10, 1)
```

```{r}
list <- list_stable
for (l in 1:599) {
  for (k in 1:60) { # nombre de fois où on obtient un même identifiant pour une ligne donnée
    a <- runif(1, vec[k + (nb-1)*60], vec[k + (nb-1)*60] + 1)
    b <- runif(1, 200 + (l-1), 200+l)
    random_points <- rbind(random_points, list(a,b))
    # trees$cell <- ifelse(
    # (vec[] <= trees$x) & (trees$x < vec[k + (nb-1)*60] + 1) & (200 + (l-1) <= trees$y) & (trees$y < 200+l), 
    # list_stable[nb],
    # trees$cell)
  }
  list <- shift(list, n = trend, type = "cyclic") # shift for each line
}

# NB: 35 940 points are randomly selected if nb = 5
# 71 880 points are randomly selected if nb = 8, idem with 10
# whereas we should have exactly 36 000 cells of each type

# PROBLEM
# N'importe quoi, ne prend pas en compte le shift
```

```{r}
colnames(random_points) <- list("x", "y")
```

```{r}
plot(x = random_points$x, y = random_points$y, main = "Random points", panel.first=grid())
```

```{r}
plot(x = random_points[(random_points$x < 210),]$x, y = random_points[(random_points$x < 210),]$y, main = "Random points", panel.first=grid(), xlim = c(200, 220), ylim = c(200, 300))
# Pas du tout random quand nb = 10
```

```{r}
for (r in row) {
  
}
```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```




